export default class OptimalGaps{constructor(a){return this.$container=a.container,this.$elements=a.elements,this.offset=a.offset,this.initialGap=a.initialGap,null==this.$container||null==this.$elements||null==this.offset||null==this.initialGap?void console.warn("A required value is missing"):void(this.breakpointStart=a.breakpointStart??null,this.containerClass=a.containerClass??"js-has-scroll",this.minimunGap=a.minimunGap??10,this.minViewportWidth=a.minViewportWidth??360,this.cssCustomProperty=a.cssCustomProperty??"--optimal-gap",this.sidePaddings=a.sidePaddings??0,this.maximumGap=null,this.maxViewportWidth=null,this.isFirstCalculation=!0,this.gapsCount=this.$elements.length-1,this.loadedWithScroll=!1,this.optimalGap=0,this.$container.style.setProperty("--side-paddings",`${this.sidePaddings}px`),this.$container.style.setProperty("--initial-gap",`${this.initialGap}px`),this.startCalculations(),this.createResizeObserver())}isBreakpointReached(){return null!=this.breakpointStart&&window.visualViewport.width>this.breakpointStart}startCalculations(){this.isBreakpointReached()||this.setOptimalGaps()}createResizeObserver(){const a=new window.ResizeObserver(this.startCalculations.bind(this));a.observe(this.$container)}isContainerWithScrollbar(){return this.$container.clientWidth<this.$container.children[0].getBoundingClientRect().width}elementsWidthSum(){let a=0;return this.$elements.forEach(b=>{a+=b.getBoundingClientRect().width}),a}calculatingOffset(){if(this.offset.includes("px"))return parseInt(this.offset);const a=this.$elements[this.$elements.length-1],b=a.getBoundingClientRect().width,c=parseInt(this.offset);return parseFloat((c*b/100).toFixed(4))}setOptimalGaps(){var a=Math.floor;if(1>=this.$elements.length)return;if(this.$container.classList.remove(this.containerClass),this.$container.style.removeProperty(this.cssCustomProperty),!1===this.isContainerWithScrollbar())return;const b=this.$container.getBoundingClientRect().width,c=b-this.elementsWidthSum();let d=c/this.gapsCount;d=window.Math.ceil(d);const e=(this.calculatingOffset()+this.sidePaddings)/this.gapsCount;d+=e,d<this.minimunGap&&(d=this.minimunGap),this.isFirstCalculation&&(this.maximumGap=this.initialGap+e,this.maxViewportWidth=this.elementsWidthSum()+this.gapsCount*this.initialGap+2*this.sidePaddings-1,this.maxViewportWidth=a(this.maxViewportWidth),this.isFirstCalculation=!1),d=this.gapGradualCalculation(),this.optimalGap=d,this.$container.style.setProperty(this.cssCustomProperty,`${this.optimalGap}px`),this.$container.classList.add(this.containerClass)}gapGradualCalculation(){if(null==this.maxViewportWidth)return;if(null==this.maximumGap)return;const a=window.visualViewport.width;if(a>=this.maxViewportWidth)return this.maximumGap;if(a<=this.minViewportWidth)return this.minimunGap;const b=this.maxViewportWidth-this.minViewportWidth,c=this.maximumGap-this.minimunGap,d=this.minimunGap+(a-this.minViewportWidth)/b*c;return parseFloat(d.toFixed(4))}}