export default class OptimalGaps{constructor(options){this.$container=options.container;this.$elements=options.elements;this.offset=options.offset;this.initialGap=options.initialGap;if(this.$container==null||this.$elements==null||this.offset==null||this.initialGap==null){console.warn("A required value is missing");return}this.breakpointStart=options.breakpointStart??null;this.containerClass=options.containerClass??"js-has-scroll";this.minimunGap=options.minimunGap??10;this.minViewportWidth=options.minViewportWidth??360;this.cssCustomProperty=options.cssCustomProperty??"--optimal-gap";this.sidePaddings=options.sidePaddings??0;this.maximumGap=null;this.maxViewportWidth=null;this.isFirstCalculation=true;this.gapsCount=this.$elements.length-1;this.loadedWithScroll=false;this.optimalGap=0;this.$container.style.setProperty("--side-paddings",`${this.sidePaddings}px`);this.$container.style.setProperty("--initial-gap",`${this.initialGap}px`);this.startCalculations();this.createResizeObserver()}isBreakpointReached(){return this.breakpointStart!=null&&window.visualViewport.width>this.breakpointStart}startCalculations(){if(this.isBreakpointReached()){return}this.setOptimalGaps()}createResizeObserver(){const resizeObserver=new window.ResizeObserver(this.startCalculations.bind(this));resizeObserver.observe(this.$container)}isContainerWithScrollbar(){return this.$container.clientWidth<this.$container.children[0].getBoundingClientRect().width}elementsWidthSum(){let elementsTotalWidth=0;this.$elements.forEach($tabButton=>{elementsTotalWidth+=$tabButton.getBoundingClientRect().width});return elementsTotalWidth}calculatingOffset(){if(this.offset.includes("px")){return parseInt(this.offset)}const lastElement=this.$elements[this.$elements.length-1];const lastElementWidth=lastElement.getBoundingClientRect().width;const offsetPercent=parseInt(this.offset);const offset=offsetPercent*lastElementWidth/100;return parseFloat(offset.toFixed(4))}setOptimalGaps(){if(this.$elements.length<=1){return}this.$container.classList.remove(this.containerClass);this.$container.style.removeProperty(this.cssCustomProperty);if(this.isContainerWithScrollbar()===false){return}const containerWidth=this.$container.getBoundingClientRect().width;const remainSpace=containerWidth-this.elementsWidthSum();let calculatedGap=remainSpace/this.gapsCount;calculatedGap=window.Math.ceil(calculatedGap);const offsetForEachGap=(this.calculatingOffset()+this.sidePaddings)/this.gapsCount;calculatedGap+=offsetForEachGap;if(calculatedGap<this.minimunGap){calculatedGap=this.minimunGap}if(this.isFirstCalculation){this.maximumGap=this.initialGap+offsetForEachGap;this.maxViewportWidth=this.elementsWidthSum()+this.gapsCount*this.initialGap+this.sidePaddings*2-1;this.maxViewportWidth=Math.floor(this.maxViewportWidth);this.isFirstCalculation=false}calculatedGap=this.gapGradualCalculation();this.optimalGap=calculatedGap;this.$container.style.setProperty(this.cssCustomProperty,`${this.optimalGap}px`);this.$container.classList.add(this.containerClass)}gapGradualCalculation(){if(this.maxViewportWidth==null){return}if(this.maximumGap==null){return}const viewportWidth=window.visualViewport.width;if(viewportWidth>=this.maxViewportWidth){return this.maximumGap}if(viewportWidth<=this.minViewportWidth){return this.minimunGap}const viewportRange=this.maxViewportWidth-this.minViewportWidth;const valuesRagne=this.maximumGap-this.minimunGap;const gradualValue=this.minimunGap+(viewportWidth-this.minViewportWidth)/viewportRange*valuesRagne;return parseFloat(gradualValue.toFixed(4))}}